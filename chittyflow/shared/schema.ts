import { sql } from 'drizzle-orm';
import {
  index,
  jsonb,
  pgTable,
  timestamp,
  varchar,
  text,
  integer,
  boolean,
  real,
} from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
import { relations } from "drizzle-orm";

// Session storage table.
// (IMPORTANT) This table is mandatory for Replit Auth, don't drop it.
export const sessions = pgTable(
  "sessions",
  {
    sid: varchar("sid").primaryKey(),
    sess: jsonb("sess").notNull(),
    expire: timestamp("expire").notNull(),
  },
  (table) => [index("IDX_session_expire").on(table.expire)],
);

// User storage table.
// (IMPORTANT) This table is mandatory for Replit Auth, don't drop it.
export const users = pgTable("users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  email: varchar("email").unique(),
  firstName: varchar("first_name"),
  lastName: varchar("last_name"),
  profileImageUrl: varchar("profile_image_url"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Tasks table for gentle task management
export const tasks = pgTable("tasks", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  title: text("title").notNull(),
  description: text("description"),
  isCompleted: boolean("is_completed").default(false),
  isAutoHandled: boolean("is_auto_handled").default(false),
  energyLevel: varchar("energy_level", { enum: ["low", "medium", "high"] }).default("medium"),
  category: varchar("category").default("general"),
  completedAt: timestamp("completed_at"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Energy tracking table
export const energyLogs = pgTable("energy_logs", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  energyLevel: varchar("energy_level", { enum: ["low", "medium", "high"] }).notNull(),
  mood: varchar("mood"),
  notes: text("notes"),
  timestamp: timestamp("timestamp").defaultNow(),
});

// Celebrations table for tracking wins
export const celebrations = pgTable("celebrations", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  title: text("title").notNull(),
  description: text("description"),
  type: varchar("type", { enum: ["task_completed", "auto_handled", "streak", "milestone"] }).notNull(),
  isAutoGenerated: boolean("is_auto_generated").default(true),
  createdAt: timestamp("created_at").defaultNow(),
});

// Auto-handled activities tracking
export const autoActivities = pgTable("auto_activities", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  type: varchar("type", { enum: ["email", "calendar", "document", "context_switching"] }).notNull(),
  title: text("title").notNull(),
  description: text("description"),
  status: varchar("status", { enum: ["active", "completed", "paused"] }).default("active"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Connected services for real automation
export const connectedServices = pgTable("connected_services", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  serviceType: varchar("service_type", { enum: ["gmail", "outlook", "google_calendar", "outlook_calendar", "google_drive", "dropbox", "slack", "discord", "twitter", "linkedin"] }).notNull(),
  serviceName: text("service_name").notNull(),
  accountEmail: varchar("account_email"), // The email/identifier for this specific account
  accountDisplayName: varchar("account_display_name"), // User-friendly name for this account
  accessToken: text("access_token"),
  refreshToken: text("refresh_token"),
  expiresAt: timestamp("expires_at"),
  isActive: boolean("is_active").default(true),
  lastSync: timestamp("last_sync"),
  settings: jsonb("settings").default({}),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// AI agent actions log
export const agentActions = pgTable("agent_actions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  serviceId: varchar("service_id").references(() => connectedServices.id, { onDelete: "cascade" }),
  actionType: varchar("action_type", { enum: ["email_response", "email_organize", "calendar_manage", "document_organize", "unsubscribe", "context_save", "proactive_suggestion"] }).notNull(),
  title: text("title").notNull(),
  description: text("description"),
  actionData: jsonb("action_data").default({}),
  userApprovalRequired: boolean("user_approval_required").default(false),
  isApproved: boolean("is_approved"),
  isExecuted: boolean("is_executed").default(false),
  executedAt: timestamp("executed_at"),
  createdAt: timestamp("created_at").defaultNow(),
});

// Smart rules and patterns the AI learns
export const automationRules = pgTable("automation_rules", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  ruleType: varchar("rule_type", { enum: ["email_filter", "calendar_preference", "context_pattern", "energy_pattern"] }).notNull(),
  name: text("name").notNull(),
  description: text("description"),
  conditions: jsonb("conditions").notNull(),
  actions: jsonb("actions").notNull(),
  confidence: integer("confidence").default(50), // How confident the AI is about this rule
  timesTriggered: integer("times_triggered").default(0),
  isActive: boolean("is_active").default(true),
  learnedFromUser: boolean("learned_from_user").default(false),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Transition rituals for moving between tasks or returning from breaks
export const transitionRituals = pgTable("transition_rituals", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  ritualType: varchar("ritual_type", { enum: ["task_switch", "break_return", "focus_prep", "day_start", "day_end"] }).notNull(),
  title: varchar("title").notNull(),
  description: text("description"),
  steps: text("steps").array().notNull(), // Array of ritual steps
  estimatedMinutes: integer("estimated_minutes").notNull().default(2),
  isEnabled: boolean("is_enabled").notNull().default(true),
  useCount: integer("use_count").notNull().default(0),
  lastUsed: timestamp("last_used"),
  createdAt: timestamp("created_at").defaultNow(),
});

// Track transition sessions
export const transitionSessions = pgTable("transition_sessions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  ritualId: varchar("ritual_id").references(() => transitionRituals.id, { onDelete: "set null" }),
  transitionType: varchar("transition_type", { enum: ["task_to_task", "break_to_task", "focus_prep", "day_start", "day_end"] }).notNull(),
  fromTask: varchar("from_task"), // Task ID if transitioning from a task
  toTask: varchar("to_task"), // Task ID if transitioning to a task
  completedSteps: text("completed_steps").array().notNull().default(sql`'{}'`),
  wasHelpful: boolean("was_helpful"), // User feedback
  notes: text("notes"),
  startedAt: timestamp("started_at").defaultNow(),
  completedAt: timestamp("completed_at"),
});

// Relations
export const usersRelations = relations(users, ({ many }) => ({
  tasks: many(tasks),
  energyLogs: many(energyLogs),
  celebrations: many(celebrations),
  autoActivities: many(autoActivities),
}));

export const tasksRelations = relations(tasks, ({ one }) => ({
  user: one(users, {
    fields: [tasks.userId],
    references: [users.id],
  }),
}));

export const energyLogsRelations = relations(energyLogs, ({ one }) => ({
  user: one(users, {
    fields: [energyLogs.userId],
    references: [users.id],
  }),
}));

export const celebrationsRelations = relations(celebrations, ({ one }) => ({
  user: one(users, {
    fields: [celebrations.userId],
    references: [users.id],
  }),
}));

export const autoActivitiesRelations = relations(autoActivities, ({ one }) => ({
  user: one(users, {
    fields: [autoActivities.userId],
    references: [users.id],
  }),
}));

export const connectedServicesRelations = relations(connectedServices, ({ one, many }) => ({
  user: one(users, {
    fields: [connectedServices.userId],
    references: [users.id],
  }),
  agentActions: many(agentActions),
}));

export const agentActionsRelations = relations(agentActions, ({ one }) => ({
  user: one(users, {
    fields: [agentActions.userId],
    references: [users.id],
  }),
  service: one(connectedServices, {
    fields: [agentActions.serviceId],
    references: [connectedServices.id],
  }),
}));

export const automationRulesRelations = relations(automationRules, ({ one }) => ({
  user: one(users, {
    fields: [automationRules.userId],
    references: [users.id],
  }),
}));

export const transitionRitualsRelations = relations(transitionRituals, ({ one, many }) => ({
  user: one(users, {
    fields: [transitionRituals.userId],
    references: [users.id],
  }),
  sessions: many(transitionSessions),
}));

export const transitionSessionsRelations = relations(transitionSessions, ({ one }) => ({
  user: one(users, {
    fields: [transitionSessions.userId],
    references: [users.id],
  }),
  ritual: one(transitionRituals, {
    fields: [transitionSessions.ritualId],
    references: [transitionRituals.id],
  }),
}));

// Schemas for validation
export const insertTaskSchema = createInsertSchema(tasks).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  completedAt: true,
});

export const insertEnergyLogSchema = createInsertSchema(energyLogs).omit({
  id: true,
  timestamp: true,
});

export const insertCelebrationSchema = createInsertSchema(celebrations).omit({
  id: true,
  createdAt: true,
});

export const insertAutoActivitySchema = createInsertSchema(autoActivities).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertConnectedServiceSchema = createInsertSchema(connectedServices).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  lastSync: true,
});

export const insertAgentActionSchema = createInsertSchema(agentActions).omit({
  id: true,
  createdAt: true,
  executedAt: true,
});

export const insertAutomationRuleSchema = createInsertSchema(automationRules).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  timesTriggered: true,
});

export const insertTransitionRitualSchema = createInsertSchema(transitionRituals).omit({
  id: true,
  createdAt: true,
  useCount: true,
  lastUsed: true,
});

export const insertTransitionSessionSchema = createInsertSchema(transitionSessions).omit({
  id: true,
  startedAt: true,
  completedAt: true,
});

// Types
export type UpsertUser = typeof users.$inferInsert;
export type User = typeof users.$inferSelect;
export type Task = typeof tasks.$inferSelect;
export type InsertTask = z.infer<typeof insertTaskSchema>;
export type EnergyLog = typeof energyLogs.$inferSelect;
export type InsertEnergyLog = z.infer<typeof insertEnergyLogSchema>;
export type Celebration = typeof celebrations.$inferSelect;
export type InsertCelebration = z.infer<typeof insertCelebrationSchema>;
export type AutoActivity = typeof autoActivities.$inferSelect;
export type InsertAutoActivity = z.infer<typeof insertAutoActivitySchema>;
export type ConnectedService = typeof connectedServices.$inferSelect;
export type InsertConnectedService = z.infer<typeof insertConnectedServiceSchema>;
export type AgentAction = typeof agentActions.$inferSelect;
export type InsertAgentAction = z.infer<typeof insertAgentActionSchema>;
export type AutomationRule = typeof automationRules.$inferSelect;
export type InsertAutomationRule = z.infer<typeof insertAutomationRuleSchema>;
export type TransitionRitual = typeof transitionRituals.$inferSelect;
export type InsertTransitionRitual = z.infer<typeof insertTransitionRitualSchema>;
export type TransitionSession = typeof transitionSessions.$inferSelect;
export type InsertTransitionSession = z.infer<typeof insertTransitionSessionSchema>;

// Executive Function Support tables
export const focusSessions = pgTable("focus_sessions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull(),
  taskName: varchar("task_name").notNull(),
  plannedMinutes: integer("planned_minutes").notNull(),
  actualMinutes: integer("actual_minutes"),
  breakCount: integer("break_count").default(0),
  isHyperfocus: boolean("is_hyperfocus").default(false),
  mood: varchar("mood"),
  energyBefore: varchar("energy_before").notNull(),
  energyAfter: varchar("energy_after"),
  startedAt: timestamp("started_at").defaultNow(),
  endedAt: timestamp("ended_at"),
});

export const timeEstimates = pgTable("time_estimates", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull(),
  taskName: varchar("task_name").notNull(),
  estimatedMinutes: integer("estimated_minutes").notNull(),
  actualMinutes: integer("actual_minutes"),
  confidence: varchar("confidence", { enum: ["low", "medium", "high"] }).notNull(),
  createdAt: timestamp("created_at").defaultNow(),
});

export const decisionSupport = pgTable("decision_support", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull(),
  question: text("question").notNull(),
  options: text("options").array().notNull(),
  selectedOption: varchar("selected_option"),
  decisionMethod: varchar("decision_method", { 
    enum: ["pros_cons", "coin_flip", "gut_feeling", "timer", "structured"] 
  }).notNull(),
  timeSpentMinutes: integer("time_spent_minutes"),
  confidence: integer("confidence"),
  createdAt: timestamp("created_at").defaultNow(),
  decidedAt: timestamp("decided_at"),
});

// Smart Automation tables
export const userPatterns = pgTable("user_patterns", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull(),
  patternType: varchar("pattern_type").notNull(), // "productivity_peak", "energy_dip", "focus_duration"
  timeOfDay: varchar("time_of_day"), // "morning", "afternoon", "evening"
  dayOfWeek: varchar("day_of_week"),
  confidence: real("confidence").notNull(), // 0-1 confidence score
  dataPoints: integer("data_points").default(1),
  insights: jsonb("insights"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

export const smartSuggestions = pgTable("smart_suggestions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull(),
  suggestionType: varchar("suggestion_type").notNull(), // "optimal_timing", "energy_break", "hydration", "context_switch"
  title: varchar("title").notNull(),
  description: text("description").notNull(),
  actionData: jsonb("action_data"), // Additional data for the suggestion
  isAcknowledged: boolean("is_acknowledged").default(false),
  wasHelpful: boolean("was_helpful"),
  priority: varchar("priority", { enum: ["low", "medium", "high"] }).default("medium"),
  expiresAt: timestamp("expires_at"),
  createdAt: timestamp("created_at").defaultNow(),
});

export const contextualNudges = pgTable("contextual_nudges", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull(),
  triggerType: varchar("trigger_type").notNull(), // "time_based", "calendar_event", "energy_level", "task_completion"
  nudgeText: varchar("nudge_text").notNull(),
  isGentle: boolean("is_gentle").default(true),
  frequency: varchar("frequency", { enum: ["once", "daily", "weekly", "as_needed"] }).default("as_needed"),
  lastShown: timestamp("last_shown"),
  effectiveness: real("effectiveness"), // User feedback score
  createdAt: timestamp("created_at").defaultNow(),
});

// Insert schemas for new tables
export const insertFocusSessionSchema = createInsertSchema(focusSessions).omit({
  id: true,
  startedAt: true,
  endedAt: true,
});

export const insertTimeEstimateSchema = createInsertSchema(timeEstimates).omit({
  id: true,
  createdAt: true,
});

export const insertDecisionSupportSchema = createInsertSchema(decisionSupport).omit({
  id: true,
  createdAt: true,
  decidedAt: true,
});

export const insertUserPatternSchema = createInsertSchema(userPatterns).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertSmartSuggestionSchema = createInsertSchema(smartSuggestions).omit({
  id: true,
  createdAt: true,
});

export const insertContextualNudgeSchema = createInsertSchema(contextualNudges).omit({
  id: true,
  createdAt: true,
  lastShown: true,
});

// New types
export type FocusSession = typeof focusSessions.$inferSelect;
export type InsertFocusSession = z.infer<typeof insertFocusSessionSchema>;
export type TimeEstimate = typeof timeEstimates.$inferSelect;
export type InsertTimeEstimate = z.infer<typeof insertTimeEstimateSchema>;
export type DecisionSupport = typeof decisionSupport.$inferSelect;
export type InsertDecisionSupport = z.infer<typeof insertDecisionSupportSchema>;
export type UserPattern = typeof userPatterns.$inferSelect;
export type InsertUserPattern = z.infer<typeof insertUserPatternSchema>;
export type SmartSuggestion = typeof smartSuggestions.$inferSelect;
export type InsertSmartSuggestion = z.infer<typeof insertSmartSuggestionSchema>;
export type ContextualNudge = typeof contextualNudges.$inferSelect;
export type InsertContextualNudge = z.infer<typeof insertContextualNudgeSchema>;
